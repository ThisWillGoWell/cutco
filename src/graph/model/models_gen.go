// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type AuthPayload struct {
	Token string `json:"token"`
}

type ChangeMeInput struct {
	OldPassword *string `json:"oldPassword"`
	Password    *string `json:"password"`
	DisplayName *string `json:"displayName"`
	Description *string `json:"description"`
	Email       *string `json:"email"`
	// Delete Account
	Delete *bool `json:"delete"`
}

type ChangeMePayload struct {
	Success bool    `json:"success"`
	Me      *MeUser `json:"me"`
}

// A string of messages between users
type ChatChannel struct {
	// the id of the chat channel
	ID string `json:"id"`
	// a friently name for a chat
	// for whisper chats will just be whisper
	Name *string `json:"name"`
	// when the channel was created
	CreatedAt *time.Time `json:"createdAt"`
	// the type of channel
	Type ChannelType `json:"type"`
	// messages in channel
	Messages []*ChatMessage `json:"messages"`
	// other members in the channel
	// does not reutrn the id of the userdao
	Members []*User `json:"members"`
}

// A chat message
type ChatMessage struct {
	// id of the message
	ID string `json:"id"`
	// userdao who sent the message
	User *User `json:"userdao"`
	// message contents
	Message string `json:"message"`
	// when the message was sent
	CreatedAt time.Time `json:"createdAt"`
	// timestamp, but more precise. cant use Time! because of
	// https://github.com/99designs/gqlgen/issues/1510
	PaginationKey string `json:"paginationKey"`
	// what chat channel the message belongs to
	Channel *ChatChannel `json:"channel"`
}

// A company that users can buy/sell parts of
type Company struct {
	// unique id for this company
	ID string `json:"id"`
	// displany name
	Name string `json:"name"`
	// company stock symbol
	Symbol string `json:"symbol"`
	// the owner of the company
	Owner *User `json:"owner"`
	// when was the company created at
	CreatedAt time.Time `json:"createdAt"`
	// company long description
	Description string `json:"description"`
	// shares that are owned of this company
	// comapny -> userdao relation
	Shares []*Share `json:"shares"`
	// current value of the shares
	Value int `json:"value"`
	// the historcal values of the company
	// currently not working
	Histroy []*ValueHistory `json:"histroy"`
	// the stock transcations of the company
	Transactions []*Transaction `json:"transactions"`
	// the amount of current open shares on the market
	OpenShares *int `json:"openShares"`
}

// Create a company
type CreateCompanyInput struct {
	Name        string `json:"name"`
	Symbol      string `json:"symbol"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

type DeletePayload struct {
	Error *string `json:"Error"`
}

// Read commpaines
type GetCompanyInput struct {
	// Load a single company
	CompanyID *string `json:"companyID"`
	// Load many companines
	CompanyIDs []string `json:"companyIDs"`
}

type GetShareInput struct {
	// Company the share belongs too
	CompanyID string `json:"companyID"`
	// UserID of the holder
	HolderID string `json:"holderID"`
	// Where in the transaction history should start to scan
	// defualt: time.Now()
	TransactionStart *time.Time `json:"transactionStart"`
	// Limit of the number of transcations to return
	// default: 10
	TransactionLimit *int `json:"transactionLimit"`
}

// Get users by ID or IDS
type GetUsersInput struct {
	UserID  string   `json:"UserID"`
	UserIDs []string `json:"UserIDs"`
}

type LoginInput struct {
	Login    string `json:"login"`
	Password string `json:"password"`
}

// Things on a userdao that only they should ever need to know about/have no relation to the game
type MeUser struct {
	// The userdao that belogs to the userdao
	User *User `json:"userdao"`
	// The userdao's current email on file, could be nil
	Email *string `json:"email"`
	// The userdao's login
	Login string `json:"login"`
}

// Read chat messages
type ReadChatMessagesInput struct {
	// (Optional) read messages just in channel, if empty will return all channels the userdao is apart of
	ChannelID *string `json:"channelID"`
	// the max number of messages to return
	// default: 5
	MessagesLimit *int `json:"messagesLimit"`
	// where to start reading messages at
	// defualt: time.Now()
	StartTime *time.Time `json:"startTime"`
	// pagination done though time string, cant use Time because of
	// https://github.com/99designs/gqlgen/issues/1510
	PaginationKey *string `json:"paginationKey"`
}

// Send a chat message to a channel or userdao
type SendChatInput struct {
	// Send message to channel id
	ChannelID *string `json:"channelID"`
	// if there currently is no channel for a userdao whisper, you can provide the
	// userdao id of the target userdao, a new channel will be created
	UserID *string `json:"userID"`
	// message string to send
	Message string `json:"message"`
}

// A peice of a company that a userdao can own
type Share struct {
	// the amount of shares the userdao owns
	Count int `json:"count"`
	// the company the share relates too
	Company *Company `json:"company"`
	// the holder of the shares
	Holder *User `json:"holder"`
	// historcal transcactions of on the share
	Transactions []*Transaction `json:"transactions"`
}

type SignupInput struct {
	Login        string              `json:"login"`
	Email        *string             `json:"email"`
	DisplayName  string              `json:"displayName"`
	Password     string              `json:"password"`
	Description  string              `json:"description"`
	InvestorType string              `json:"investorType"`
	Company      *CreateCompanyInput `json:"company"`
}

// Buy or sell a stock
// The company must have open shares, and the userdao must be able to afford the cost
type TradeInput struct {
	// The ID of the company to buy/sell a stock of
	CompanyID string `json:"companyID"`
	// the amount of shares the userdao wants to buy/sell
	// positive amount will result in a buy
	// negitive amount will result in a sell
	Amount int `json:"amount"`
	// the price the userdao currently thinks the share is at
	// must be equal to the current company.value
	Price int `json:"price"`
}

// result of a trade
type TradePayload struct {
	// Was the trade a success or not
	Success *bool `json:"Success"`
}

// a historacal transction on a share
// created when a userdao buys or sells a stock
type Transaction struct {
	// when the transcation took place
	Time time.Time `json:"time"`
	// the value of the stock at the time of the transaction
	Value int `json:"value"`
	// the amount of shares bought/sold
	Count int `json:"count"`
	// the userdao who bought/sold the share
	User *User `json:"userdao"`
}

type User struct {
	// unique id for the userdao
	ID string `json:"id"`
	// # when was the userdao last active
	LastActiveAt time.Time `json:"lastActiveAt"`
	// # the name the userdao is seen in game
	Name string `json:"name"`
	// the description of the userdao
	Description string `json:"description"`
	// when was the userdao created at
	CreatedAt time.Time `json:"createdAt"`
	// the company the userdao owns
	Company *Company `json:"company"`
	// the shares a userdao owns
	Shares []*Share `json:"shares"`
	// the amount of money the userdao has
	Wallet int `json:"wallet"`
	// the type of investor
	InvestorType string `json:"investorType"`
}

// historcal value of a company
type ValueHistory struct {
	Value *int       `json:"value"`
	Time  *time.Time `json:"time"`
}

// Types of channel
type ChannelType string

const (
	ChannelTypePrivate ChannelType = "PRIVATE"
	ChannelTypePublic  ChannelType = "PUBLIC"
	ChannelTypeWhisper ChannelType = "WHISPER"
)

var AllChannelType = []ChannelType{
	ChannelTypePrivate,
	ChannelTypePublic,
	ChannelTypeWhisper,
}

func (e ChannelType) IsValid() bool {
	switch e {
	case ChannelTypePrivate, ChannelTypePublic, ChannelTypeWhisper:
		return true
	}
	return false
}

func (e ChannelType) String() string {
	return string(e)
}

func (e *ChannelType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelType", str)
	}
	return nil
}

func (e ChannelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
